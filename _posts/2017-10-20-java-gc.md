---
layout: post
title: Java Garbage Collection
category: PL
tags: 
    - java
    - GC
---

## 常用的垃圾回收算法包括
### 标记清除算法mark-sweep
#### 标记出所有垃圾对象，然后依次删除
- 垃圾对象越多，效率越低
- 容易产生内存碎片

### 复制算法Copy
#### 内存区域等分为两块，只有一块内存区域可以使用，另一块为空
#### 对使用中的那块内存区域中的对象进行标记（可达性分析），标记出非垃圾对象之后，把它们依次复制到另一块内存区域，并清空当前内存区域
- 存活的对象越多，回收效率越低，适用于垃圾对象比较多的场合。这是年轻代使用复制算法的原因。
- 浪费内存

### 标记整理算法mark-compact
#### 标记出所有被有效引用的对象，然后往内存的开始位置挪动，然后清除边界之后的对象。
- 存活的对象越少，回收效率越高，适用于对象比较稳定的场合。
- 相比复制算法节约内存
- 上面两条时年老代使用标记整理算法的原因

---
## Java内存区域
### 堆
- 生成的对象在这里
- 线程共享
### 方法区
- 已被加载的类的信息，常量，类静态变量，JIT编译器编译得到的代码
- 线程共享
### 虚拟机栈
- 线程私有
### 本地方法栈
### 程序计数器

---
## 可达性分析
### 从根对象开始标记开始，对引用到的对象依次进行标记
### 根对象通常是
- java虚拟机栈中引用的对象
- 类静态变量引用的对象
- 常量应用的对象
- 

---
## Java把内存分为年轻代和年老代
### 基于这样一个观察：大部分对象生存期很短，生存期很长的对象很少
### young generation
- 分为eden, survivor 1和survivor 2区，默认比例是8:1:1
- 年轻代默认使用copy算法
- 年轻代虽然使用复制算法，但是并不是按照原始的复制算法那样把内存等分为两块，因为这样太浪费内存空间了！！！
### old generation
### 使用mark-compact算法

---
## Minor GC
- eden满了触发minor-gc
- minor gc试图对eden和其中一个survivor内（假设为1）的对象从根对象开始进行标记，标记完之后，对于没有被引用但是拥有finalize方法的对象，把它们放入F-Queue队列，进行运行，之后再做一次标记，把第二次标记之后所有被引用的对象放入survivor 2（有可能放不下）。然后清理eden和survivor 1。下次minor gc被触发时，要清理eden和survivor 2。
- 在minor gc中存活下来的对象，年龄会加1，如果超过一定值（-XX:MaxTenuringThreshold），会被转移到老年代。另外，对于survivor区中的对象，如果相同年龄的对象的大小总和超过该区总空间的一半，那么等于或者大于该年龄的对象直接进入老年代。
- 大对象（-XX:PretenureSizeThreshold）在生成时直接进入老年代，因为大对象很可能生存期较长，最终会进入老年代，这样做可以避免从年轻代拷贝到老年代。

## Full GC
- 每次Minor gc时，都会计算老年代对象的平均大小，如果这个值大于老年代剩余空间，则触发Full gc；否则，查看HandlePromotionFailure选项，如果这个选项为真，那么只进行minor gc(在进行minor gc时可能有对象从年轻代转移到老年代，触发full gc，只是在“老年代剩余空间大于老年代对象的平均大小”的前提下，这种可能性比较小)，否则进行Full gc。


---
## 特殊的引用
- 通常被用来实现缓存
### Strong reference就是普通的引用
### Soft reference
- 当虚拟机发现要发生OutOfMemoryError时，首先回收所有只被Soft reference引用的对象，如果在回收后仍然内存不足，才会触发OOM。
### Weak reference
- 当虚拟机进行GC时，回收所有只被Weak reference引用的对象
### Phantom reference
- 为对象设置一个Phantom reference, 对该对象没有影响，除了在该对象被内存回收时，会收到一个系统通知
